// Constants
def MIN_GRADLE_VERSION = '8.5'
def MAX_EXCLUDED_GRADLE_VERSION = '9'
def NEOFORGE_MOD_LOADER = 'neoforge'


def DEFAULT_JAVA_VERSION = '21'
def DEFAULT_MOD_LOADER = NEOFORGE_MOD_LOADER
def DEFAULT_MOD_AUTHOR = 'awesomeshot5051'
def DEFAULT_RELEASE_TYPE = 'alpha'
def DEFAULT_MINECRAFT_USER_NAME_PREFIX = 'awesomeshot5051'

def DEFAULT_CONFIGBUILDER_VERSION = '2.0.1'
def DEFAULT_MIXIN_ANNOTATION_PROCESSOR_VERSION = '0.8.4'
ext.enable_modrinth_upload = false
ext.curseforge_upload = false
// Gradle version checks
def gradle_version = VersionNumber.parse(getProject().getGradle().getGradleVersion())
// Check for min Gradle version
if (gradle_version < VersionNumber.parse(MIN_GRADLE_VERSION)) {
    throw new RuntimeException("Outdated Gradle version, please update to ${MIN_GRADLE_VERSION} or later")
}
// Check for max Gradle version
if (gradle_version >= VersionNumber.parse(MAX_EXCLUDED_GRADLE_VERSION)) {
    throw new RuntimeException("Gradle version too new, please use <${MAX_EXCLUDED_GRADLE_VERSION}")
}

// Variables
checkProperty('minecraft_version')

checkProperty('mod_id')
checkProperty('mod_version')
checkProperty('mod_display_name')

ext.java_version = getOrDefault('java_version', DEFAULT_JAVA_VERSION) as int
ext.mod_loader = getOrDefault('mod_loader', DEFAULT_MOD_LOADER)
ext.mod_authors = getOrDefault('mod_authors', [DEFAULT_MOD_AUTHOR], it -> stringToStringList(it))
ext.minecraft_user_name_prefix = getOrDefault('minecraft_user_name_prefix', DEFAULT_MINECRAFT_USER_NAME_PREFIX)
ext.include_mixins = getOrDefault('include_mixins', true, it -> it.toBoolean()) //TODO Maybe only for Forge/NeoForge, since they are included by default from Fabric
ext.use_mixins = getOrDefault('use_mixins', false, it -> it.toBoolean()) //TODO Maybe only for Forge/NeoForge, since they are included by default from Fabric
ext.included_projects = getOrDefault('included_projects', [], it -> stringToStringList(it))

ext.use_shadow = getOrDefault('use_shadow', true, it -> it.toBoolean())

ext.included_projects = included_projects.findAll {
    def p = findProject(it)
    if (p == null) {
        throw new RuntimeException("Project '${it}' does not exist")
    }
    return p != getProject()
}

// Libraries
ext.enable_configbuilder = getOrDefault('enable_configbuilder', false, it -> it.toBoolean())
if (enable_configbuilder) {
    ext.configbuilder_version = getOrDefault('configbuilder_version', DEFAULT_CONFIGBUILDER_VERSION)
}

// Mod loaders

ext.is_neoforge = mod_loader.equalsIgnoreCase(NEOFORGE_MOD_LOADER)

// Neoforge specific variables
if (is_neoforge) {
    checkProperty('neo_version')
}


if (is_neoforge) {
    ext.enable_accesstransformers = getOrDefault('enable_accesstransformers', false, it -> it.toBoolean())
}


//// Upload
//ext.upload_release_type = getOrDefault('upload_release_type', DEFAULT_RELEASE_TYPE)
//ext.upload_recommended = getOrDefault('upload_recommended', false, it -> it.toBoolean())
//// CurseForge upload
//ext.enable_curseforge_upload = getOrDefault('enable_curseforge_upload', true, it -> it.toBoolean())
//if (enable_curseforge_upload) {
//    //checkPlugin('com.awesomeshot5051.cursegradle')
//    checkProperty('curseforge_upload_id')
//    ext.curseforge_upload_include_prefix = getOrDefault('curseforge_upload_include_prefix', true, it -> it.toBoolean())
//    ext.curseforge_upload_minecraft_versions = getOrDefault('curseforge_upload_minecraft_versions', [], it -> stringToStringList(it))
//    ext.curseforge_upload_optional_dependencies = getOrDefault('curseforge_upload_optional_dependencies', [], it -> stringToStringList(it))
//    ext.curseforge_upload_required_dependencies = getOrDefault('curseforge_upload_required_dependencies', [], it -> stringToStringList(it))
//}
// Modrinth upload
//ext.enable_modrinth_upload = getOrDefault('enable_modrinth_upload', true, it -> it.toBoolean())
//if (enable_modrinth_upload) {
//    //checkPlugin('com.modrinth.minotaur')
//    checkProperty('modrinth_upload_id')
//    ext.modrinth_upload_include_prefix = getOrDefault('modrinth_upload_include_prefix', true, it -> it.toBoolean())
//    // This property is optional and falls back to the selected loader
//    ext.modrinth_upload_supported_loaders = getOrDefault('modrinth_upload_supported_loaders', [], it -> stringToStringList(it))
//    // This property is optional and falls back to the selected Minecraft version
//    ext.modrinth_upload_supported_game_versions = getOrDefault('modrinth_upload_supported_game_versions', [], it -> stringToStringList(it))
//    ext.modrinth_upload_optional_dependencies = getOrDefault('modrinth_upload_optional_dependencies', [], it -> stringToStringList(it))
//    ext.modrinth_upload_required_dependencies = getOrDefault('modrinth_upload_required_dependencies', [], it -> stringToStringList(it))
//    ext.modrinth_token = getOrDefault('modrinth_token', System.env.MODRINTH_TOKEN ?: '')
//    if (modrinth_token == null || modrinth_token.isEmpty()) {
//        project.logger.error('Missing environment variable MODRINTH_TOKEN')
//    }
//}
//// Hangar upload
//ext.enable_hangar_upload = getOrDefault('enable_hangar_upload', false, it -> it.toBoolean())
//if (enable_hangar_upload) {
//    checkPlugin('io.papermc.hangar-publish-plugin')
//    checkProperty('hangar_upload_id')
//    ext.hangar_upload_minecraft_versions = getOrDefault('hangar_upload_minecraft_versions', [], it -> stringToStringList(it))
//    ext.hangar_upload_supported_loaders = getOrDefault('hangar_upload_supported_loaders', ['PAPER'], it -> stringToStringList(it))
//    ext.hangar_upload_dependencies = getOrDefault('hangar_upload_dependencies', [], it -> stringToStringList(it))
//    ext.hangar_api_key = getOrDefault('hangar_api_key', System.env.HANGAR_API_KEY ?: '')
//    if (hangar_api_key == null || hangar_api_key.isEmpty()) {
//        project.logger.error('Missing environment variable HANGAR_API_KEY')
//    }
//}
// Mod update
//ext.enable_mod_update = getOrDefault('enable_mod_update', true, it -> it.toBoolean())
//if (enable_mod_update) {
//    checkPlugin('mod-update')
//    ext.mod_update_api_key = getOrDefault('mod_update_api_key', System.env.MOD_UPDATE_API_KEY ?: '')
//    if (mod_update_api_key == null || mod_update_api_key.isEmpty()) {
//        project.logger.error('Missing environment variable MOD_UPDATE_API_KEY')
//    }
//}

// Mark the evaluation depending on all included projects, so its evaluated after them
included_projects.forEach({
    evaluationDependsOn(it)
})

// Checking if mandatory plugins exist
if (is_neoforge) {
    // Neoforge gradle
    checkPlugin('net.neoforged.gradle.moddev')
    // Neoforge mixins
}
if (use_shadow) {
    checkPlugin('com.gradleup.shadow')
}

apply plugin: 'java'
apply plugin: 'idea'

idea {
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'idea'
}

def java_language_version = JavaLanguageVersion.of(java_version)
sourceCompatibility = java_language_version
targetCompatibility = java_language_version
java.toolchain.languageVersion = java_language_version

group = getOrDefault('maven_group', "com.awesomeshot5051.${mod_id.replaceAll('_', '')}")
archivesBaseName = getOrDefault('archives_base_name', "${mod_id.replaceAll('_', '-')}-${mod_loader}")
version = mod_version

// Run configurations


// Neoforge run configuration
if (is_neoforge) {
    configurations {
        minecraftLibrary {}
        implementation.extendsFrom minecraftLibrary
    }

    runs {
        configureEach {
            modSource project.sourceSets.main
            systemProperty 'forge.logging.console.level', 'debug'
            dependencies {
                runtime project.configurations.minecraftLibrary
            }
        }
        client {
            workingDirectory file('run')
            arguments = ['--username', "${minecraft_user_name_prefix}${new Random().nextInt(1000)}"]
        }
        server {
            workingDirectory file('run/server')
            arguments = ['--nogui']
        }
    }

    sourceSets.main.resources { srcDir 'src/generated/resources' }

    if (use_mixins) {
        mixin {
            config "${mod_id}.mixins.json"
        }
    }

    if (enable_accesstransformers) {
        minecraft.accessTransformers.file file('src/main/resources/META-INF/accesstransformer.cfg')
    }
}

// This does not seem to be needed and causes issues with Forge 1.16.5
/*sourceSets.each {
    def dir = layout.buildDirectory.dir("sourcesSets/$it.name")
    it.output.resourcesDir = dir
    it.java.destinationDirectory = dir
}*/


// Dependency management
repositories {
    maven { url = 'https://maven.maxhenkel.de/repository/public' }
    maven {
        url = 'https://api.modrinth.com/maven'
        content {
            includeGroup "maven.modrinth"
        }
    }
    mavenLocal()
}

dependencies {

    if (is_neoforge) {
        implementation "net.neoforged:neoforge:${neo_version}"
    }


    included_projects.forEach({
        def hasNamedElements = project(it).getConfigurations().findByName('namedElements') != null
        def included_project = hasNamedElements ? project(path: it, configuration: 'namedElements') : project(it)
        compileOnly(included_project) {
            transitive false
        }
        if (use_shadow) {
            shadow(included_project) {
                transitive false
            }
        } else {
            runtimeOnly(included_project) {
                transitive false
            }
        }
    })

    implementation 'com.google.code.findbugs:jsr305:3.0.2'

    if (enable_configbuilder) {
        implementation "de.maxhenkel.configbuilder:configbuilder:${configbuilder_version}"
        if (use_shadow) {
            shadow "de.maxhenkel.configbuilder:configbuilder:${configbuilder_version}"
        }
        if (is_neoforge || is_forge) {
            minecraftLibrary "de.maxhenkel.configbuilder:configbuilder:${configbuilder_version}"
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    it.options.encoding = 'UTF-8'
    if (java_version > 8) {
        it.options.release = java_version
    }

    if (!is_neoforge) {
        included_projects.forEach({
            source(project(it).sourceSets.main.allSource)
        })
    }
}

if (is_neoforge) {
    tasks.withType(JavaCompile).matching(it -> !it.name.startsWith("neo")).configureEach {
        included_projects.forEach({
            source(project(it).sourceSets.main.allSource)
        })
    }
}

processResources {
    included_projects.forEach({
        from("${project(it).projectDir}/src/main/resources")
    })
}

jar {
    from('LICENSE') {
        rename { "${it}_${archivesBaseName}" }
    }

    // Manifest attributes

    // This does not seem to be needed anymore with NeoForge, but we will still add it for now
    if (is_neoforge) {
        manifest {
            attributes(['Specification-Title'     : mod_display_name,
                        'Specification-Vendor'    : mod_authors.join(', '),
                        'Specification-Version'   : '1',
                        'Implementation-Title'    : mod_display_name,
                        'Implementation-Version'  : mod_version,
                        'Implementation-Vendor'   : mod_authors.join(', '),
                        'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),])
        }
    }
}

if (use_shadow) {
    shadowJar {
        configurations = [project.configurations.shadow]
            archiveClassifier = ''
        if (enable_configbuilder) {
            relocate 'de.maxhenkel.configbuilder', "com.awesomeshot5051.${mod_id}.configbuilder"
        }
    }
}

if (is_neoforge) {
    if (use_shadow) {
        assemble.dependsOn('shadowJar')
    }
}

afterEvaluate {
    // No idea why, but sometimes Gradle complains about a prepareWorkspace task
    def prepareWorkspaceTask = tasks.findByName('prepareWorkspace')
    if (prepareWorkspaceTask == null) {
        tasks.register('prepareWorkspace') {

        }
    }
}

// NeoForge clean fix
if (is_neoforge) {
    // https://github.com/neoforged/NeoGradle/issues/18#issuecomment-1858754401
    tasks.register('customClean', Delete) {
        doLast {
            def files = []
            fileTree("build")
                    .exclude('**/expanded.lock')
                    .visit { FileVisitDetails fvd ->
                        files << fvd.file
                    }
            files.reverse()
                    .each { f ->
                        def file = file(f)
                        if (!file.exists()) return;
                        if ((file.isDirectory() && file.list().size() == 0)
                                || !file.isDirectory())
                            delete f
                    }
        }
    }
    clean.dependsOn customClean
    clean.enabled = false
}

// CurseForge Upload
if (enable_curseforge_upload) {
    def curse_game_versions
    if (curseforge_upload_minecraft_versions) {
        curse_game_versions = curseforge_upload_minecraft_versions
    } else {
        curse_game_versions = [minecraft_version]
    }
    curseforge {
        apiKey = curseforge_api_key
        project {
            id = curseforge_upload_id
            changelogType = 'markdown'
            changelog = getChangelogFile()
            releaseType = upload_release_type
            curse_game_versions.forEach {
                addGameVersion it
            }
            if (is_neoforge) {
                addGameVersion 'NeoForge'
            }
            addGameVersion "Java ${java_version}"
            mainArtifact(getUploadArtefact()) {
                if (curseforge_upload_include_prefix) {
                    displayName = "[${mod_loader.toUpperCase()}][${minecraft_version}] ${mod_display_name} ${mod_version}"
                } else {
                    displayName = "${mod_display_name} ${mod_version}"
                }
                if (curseforge_upload_optional_dependencies || curseforge_upload_required_dependencies) {
                    relations {
                        curseforge_upload_optional_dependencies.forEach({
                            optionalDependency it
                        })
                        curseforge_upload_required_dependencies.forEach({
                            requiredDependency it
                        })
                    }
                }
            }
        }
        options {
            forgeGradleIntegration = false
        }
    }
    if (use_shadow) {
        tasks.curseforge.dependsOn(shadowJar)
    } else {
        tasks.curseforge.dependsOn(jar)
    }
}

// Modrinth Upload
if (enable_modrinth_upload) {
    tasks.modrinth.configure({
        group = 'upload'
    })
    tasks.modrinthSyncBody.configure({
        group = 'upload'
    })

    modrinth {
        token = modrinth_token
        projectId = modrinth_upload_id
        versionNumber = "${mod_loader}-${mod_version}"
        if (modrinth_upload_include_prefix) {
            versionName = "[${mod_loader.toUpperCase()}][${minecraft_version}] ${mod_display_name} ${mod_version}"
        } else {
            versionName = "${mod_display_name} ${mod_version}"
        }
        uploadFile = getUploadArtefact()
        versionType = upload_release_type.toUpperCase()
        changelog = getChangelogFile().text
        if (modrinth_upload_supported_game_versions) {
            gameVersions = modrinth_upload_supported_game_versions
        } else {
            gameVersions = [minecraft_version]
        }
        if (modrinth_upload_supported_loaders) {
            loaders = modrinth_upload_supported_loaders
        } else {
            loaders = [mod_loader]
        }
        dependencies {
            modrinth_upload_optional_dependencies.forEach({
                optional.project it
            })
            modrinth_upload_required_dependencies.forEach({
                required.project it
            })
        }
        def readmeFile = file("${rootDir}/readme.md")
        if (readmeFile.exists()) {
            syncBodyFrom = readmeFile.text
        }
    }
    if (use_shadow) {
        tasks.modrinth.dependsOn(shadowJar)
    } else {
        tasks.modrinth.dependsOn(jar)
    }
}
// Mod Update

// Utility functions
/**
 * Checks if a property exists or falls back to a default value.
 *
 * @param propertyName the name of the property to check
 * @param defaultValue the default value if the property doesn't exists
 * @param mutator mutates the return value (Only applied if the property exists)
 * @return the property
 */
def <T> T getOrDefault(String propertyName, T defaultValue = null, Closure mutator = { it }) {
    if (!project.hasProperty(propertyName)) {
        return defaultValue
    }
    return mutator(getProperty(propertyName))
}

/**
 * Throws an exception if a property doesn't exist.
 *
 * @param propertyName the name of the property to check
 */
def checkProperty(String propertyName) {
    if (!project.hasProperty(propertyName)) {
        throw new RuntimeException("No property '${propertyName}' defined")
    }
}

def hasPlugin(String pluginName) {
    return getPluginManager().hasPlugin(pluginName)
}

def checkPlugin(String pluginName) {
    if (!hasPlugin(pluginName)) {
        throw new RuntimeException("Missing plugin '${pluginName}'")
    }
}

static def stringToStringList(String str) {
    return str.split(',').collect({ it.trim() })
}

def getChangelogFile() {
    def file = file('changelog.md').exists() ? file('changelog.md') : file("${rootDir}/changelog.md")
    if (file == null || !file.exists()) {
        throw new RuntimeException('Missing changelog')
    }
    return file
}

def getUploadArtefact() {
    return (use_shadow ? shadowJar : jar)
}
